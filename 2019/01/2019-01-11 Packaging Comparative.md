# Summary table

| Packaging | System        | Root | Single file | Centralized     | Artifact size   | "Real" size  | Easy to use | Easy to maintain | Can be automated  |
|-----------|---------------|------|-------------|-----------------|-----------------|--------------|-------------|------------------|-------------------|
| RPM/copr  | Fedora/CentOS | Yes  | No          | Yes (copr)      | 23 MiB          | 81 MiB       | Trivial     | Easy (Elements)  | Yes               |
| RPM/epel  | Fedora/CentOS | Yes  | No          | Yes (epel)      | 23 MiB          | 81 MiB       | Trivial     | Medium (Manual)  | Not worth?        |
| Deb       | Debian/Ubuntu | Yes  | No          | Yes (ppa)       | ~23 MiB         | ~81 MiB      | Trivial     | Medium (Manual)  | Yes               |
| Docker    | Any           | No\* | Yes         | Yes (DockerHub) | ~137 MiB        | ~500 MiB     | Hard        | Easy             | Yes               |
| Flatpak   | Linux         | No\* | Yes         | Yes (Flathub)   | 24 MiB          | 286 MiB      | Medium      | Easy             | Yes               |
| Snap      | Linux         | Yes  | Yes         | Yes (Store)     | ?               | ?            | Easy        | ?                | ?                 |
| AppImage  | Linux         | No   | Yes         | No              | 54 MiB          | 54 MiB       | Trivial     | Trivial          | Yes               |
| Homebrew  | Linux/MacOSX  | No   | -           | Yes (GitHub)    | From sources    | From sources | Medium      | Easy             | Not worth/No need |

* **System**: OS or distribution where it will work
* **Root**: Requires root to install software ()
* **Single file**: Software *and* dependencies can be shipped as one single artifact
* **Centralized**: There is a central "standard" repository to host the required files (i.e. copr, or DockerHub)
* **SExtractor size**: Artifact download size (including direct dependencies, but not runtime) 
* **"Real size"**: Full installation size
* **Easy to use**: How convoluted it is to make it work from the terminal? Run `SExtractor` and done? Need more setup?
* **Easy to maintain**: How much burden is to do a new release?
* **Can be automated**: Normally, almost anything can. Is it worth, though?


# Details

## [RPM/copr](http://copr.fedorainfracloud.org/)

### System
Works for Fedora and CentOS.

### Root
Requires root for enabling the repo, and to install the RPMS.

```sh
sudo dnf copr enable "aalvarez/ObsGE"
```

### Single file
No. One RPM per component. Well, technically you could have one single RPM, but that's not a nice approach.

### Centralized
[Copr](http://copr.fedorainfracloud.org/). RPMS are pushed there and anyone can easily install and upgrade.

### Easy to use
Trivial. `dnf install`, and it can be run on the command line as expected: `SExtractor`.

### Easy to maintain
Yes. It is controlled by us, not subject to the distribution standards, so we can leverage Elements to generate
the spec file.

### Can be automated?
Builds can be triggered on push. Copr will run a Makefile which can script the building via Elements.

* [Example of a setup for Elements](https://github.com/ayllon/Elements/tree/copr/.copr).
* [Example of a repository](https://copr.fedorainfracloud.org/coprs/aalvarez/ObsGE/)


## [RPM/epel/fedora](https://fedoraproject.org/wiki/EPEL)

### System
Works for Fedora and CentOS (via EPEL repositories).

### Root
Required to install the RPMS (and to enable EPEL, but it normally is).

## Single file
No. One RPM per component.

### Centralized
[EPEL](https://fedoraproject.org/wiki/EPEL).

### Easy to use
Trivial. `dnf install`, and it can be run on the command line as expected: `SExtractor`.

### Easy to maintain
Easy, but not trivial. Subject to the distribution standards, requires going through
[peer review](https://fedoraproject.org/wiki/Packaging:ReviewGuidelines) before it is accepted.

Every component will require to pass its own aproval process (Elements, Alexandria).

### Can be automated?
As almost anything, it can be automated, but probably not worth the effort. The spec file generated by Elements would, in any case, help.

* [Example rpm distributed on Fedora](https://src.fedoraproject.org/rpms/libmetalink/tree/master).


## Deb

### System
Debian/Ubuntu.

### Root
Requires root for installation and for enabling a PPA.

### Single file
No. One DEB per component.

### Centralized
Yes. For Ubuntu we have [PPA](https://launchpad.net/ubuntu/+ppas), but I have not found anything
similar for Debian. Would need to host it ourselves.

### Easy to use
Trivial. `apt install`, and it can be run on the command line as expected: `SExtractor`.

### Easy to maintain
With a small patch, Elements can generate the `.deb` files via cpack for the full chain. These could be stored on
an apt repository, and let users install from there.

The package generated by cpack is not as nice as the RPM generated by Elements, but doing something similar would
be likely more effort than it is worth (the tooling does not help much).

### Can be automated?
Yes, with Jenkins or the like.


## [Docker](https://www.docker.com/get-started)

### System
Docker images can be run on Windows and MacOSX too using a virtual machine behind the scenes (VirtualBox/HyperKit).

### Root
No, but the user needs to be allowed to run Docker containers.

### Single file
Yes, via [docker save](https://docs.docker.com/engine/reference/commandline/save/).

### Centralized
[Dockerhub](https://hub.docker.com/)

### Easy to use
Usage is not as straight forward (IMHO), since it requires, besides installing Docker, configuring properly user,
volumes, permissions, etc.
Of course, a relatively straight-forward (?) helper could be provided, but that's already an extra step.

### Easy to maintain
Should be, specially since the latest Docker supports [separated stages to build and to install](https://docs.docker.com/develop/develop-images/multistage-build/).

### Can be automated?
Yes.


## [Flatpak](https://www.flatpak.org/)

### System
Any Linux. It is installed by default on Fedora. Requires manual installation on other distributions, but it
widely available.

### Root
Once flatpak is installed, there is no need for `root` access to install applications, as they can
be installed on the user `$HOME` directory.

### Single file
It can be distributed as a single `.flatpak` file embedding all dependencies.

### Centralized
Yes but. [Flathub](https://flathub.org/home) is the central repository, but SExtractor will not be
accepted due to the [requirements](https://github.com/flathub/flathub/wiki/App-Requirements): only
desktop applications with a graphical interface. Phosphoros might be accepted.

### Size
The single file with all the required dependencies takes "only" 24 MiB, but the runtime increases the
required space by 262.5 MiB, adding up to 286.5 MiB. The runtime is shared with other flatpak applications,
though, so if the user is already using [flatpak apps](https://flathub.org/apps/collection/popular) the
impact is lower.

### Easy to use
As for the usability, the user would need to add `~/.local/share/flatpak/exports/bin` to the `$PATH`,
but, once done, SExtractor can be executed by its full qualified name: `ch.unige.astro.sextractorxx`
(could be changed). An alias can make the execution transparent (either point at that script, or to `flatpak run`).

### Easy to maintain
* [Example manifest files](https://gitlab.astro.unige.ch/aalvarez/ch.unige.astro)

### Can be automated?
Yes, and probably not very difficult as flatpak provides also the build environment


## [Snap](https://snapcraft.io/)

### System
Installed by default in Ubuntu. Support on other distributions seem to be
[so-so](https://kamikazow.wordpress.com/2018/06/08/adoption-of-flatpak-vs-snap-2018-edition/).

### Root
Root is required to install (I haven't found anything pointing to the contrary.)

### Single file
Yes.

### Centralized
[Snapcraft store](https://snapcraft.io/store)

### Easy to use
Easier than flatpak, as there will be a script installed with the name of the program instead of a
fully qualified name.

### Easy to maintain
?

### Can be automated?
I imagine.


## [AppImage](https://appimage.org)

### System
Any Linux, but needs to be careful  and build with the oldest-new-enough platform we can find, as newer versions
of libc and similar are likely to be backwards-compatible, but if we compile with a modern system,
older platforms [may not be able to run the binary](https://github.com/AppImage/AppImageKit/wiki/Creating-AppImages#binaries-compiled-on-old-enough-base-system).

### Root
No.

### Single file
Yes.

### Centralized
No. There is a web catalog, but can not be used like "dnf" or "apt".

### Easy to use
Ver very easy.

```bash
wget https://.../SExtractor-x86_64.AppImage
chmod a+x SExtractor-x86_64.AppImage
./SExtractor-x86_64.AppImage --help
```

Even [Torvalds likes it](https://plus.google.com/+LinusTorvalds/posts/WyrATKUnmrS).

### Easy to maintain
~~Nothing special to be done besides scripting the creation of the AppImage.~~

Handling the Python environment within the image is not trivial. We can not rely
on the system Python version, as packages may be missing and, besides, there are ABI
[incompatibility between Python versions](https://docs.python.org/3/c-api/stable.html).

I have managed to make it work, at least building in F28 and running also in Ubuntu 18.04.

### Can be automated?
Yes, and it can work with rpms, locally building...


## [Homebrew](https://brew.sh/)/[Linuxbrew](http://linuxbrew.sh/)

### System
Both Linux and MacOSX.

### Root
Not needed.

### Single file
No.

### Centralized
Via [Github repos](https://github.com/).

### Easy to use
It depends. It builds from sources, although it can also use pre-built binaries to speed up things.
Usage is not hard on itself, but since it may require compilation, there is always the chance that something
will break.

### Easy to maintain
Reasonably low maintenance once everything is setup.

* [Example Homebrew tap](https://github.com/ayllon/homebrew-obsge)

The same manifests can be used both in Linux and MacOSX. However, Linux binaries can not be specified
on the same manifest file, as the MacOSX version will not recognize it. The other way around is fine.

### Can be automated?
Maybe the pre-building of binaries, but I am not sure it is worth the effort.

### Size
Homebrew basic library takes by itself 70 MiB in Linux. MacOSX users may have it already installed anyways.
After the installation of SExtractor, the space used is ~854MiB. Note that this may probably change between
platforms?


## Comments
For Linux only, AppImage seems to be the most flexible options. Native formats as RPM or DEB are not
easily portable between distributions, so they do require a non trivial amount of maintenance.

If Fedora only is good enough, then copr can fit the bill.

Homebrew could be a good option for MacOSX users. Guaranteeing that it will compile in any Linux may prove to
be complicated. It was working, and when writing this document, it wouldn't work anymore during the linking of
boost-python 😒
